# ポケモンカードデータベース構築計画

## 概要

ポケモンカード検索サイトを高速化するため、全カード情報を事前にデータベースに保存する計画です。これにより、検索処理をミリ秒単位で実現できます。

- **収集対象**: ひとまず**現行レギュレーション**のカードを対象とする。公式カード検索ページは初期表示で現行レギュレーションが抽出されるため、デフォルトで検索ページから基本情報を取得し、続けて詳細ページから HP・ワザ・特性・効果本文などを収集する。
- **全レギュレーション**: XY/SM/S/SV すべてが必要な場合は、収集スクリプトの `--all` オプションで対応する。

---

## 1. データベース設計

### 1.1 スキーマ設計

#### 基本カード情報テーブル（cards）

※本ドキュメントのSQLは **PostgreSQL** 用です。MySQLの `INDEX`/`FULLTEXT INDEX` は PostgreSQL では無効なため、インデックスは別の `CREATE INDEX` で作成します。

```sql
CREATE TABLE cards (
  -- 基本情報
  card_id VARCHAR(5) PRIMARY KEY,           -- カードID（5桁）
  name TEXT NOT NULL,                       -- カード名（短縮版）
  full_name TEXT,                           -- 正式名称（セット情報含む）
  category TEXT NOT NULL,                   -- カテゴリ（ポケモン/グッズ/サポート/スタジアム/エネルギー）
  
  -- 画像・URL情報
  image_url TEXT,                           -- 画像URL
  detail_url TEXT,                          -- 詳細ページURL
  
  -- ポケモンカード固有情報
  hp INTEGER,                               -- HP（ポケモンのみ）
  card_type TEXT,                           -- タイプ（ポケモン/エネルギー共通。複合は「草/炎」のようにスラッシュ区切り）
  energy_subtype TEXT,                      -- エネルギー種別（基本/特殊）
  evolution_stage TEXT,                     -- 進化段階（たね/1進化/2進化）
  pokemon_number TEXT,                      -- ポケモン図鑑番号
  
  -- 戦闘パラメータ
  weakness TEXT,                            -- 弱点（例: "×2"）
  resistance TEXT,                          -- 抵抗力（例: "-30"）
  retreat_cost INTEGER,                     -- にげるコスト
  
  -- セット情報
  set_code TEXT,                            -- セットコード（例: "M2a"）
  set_name TEXT,                            -- セット名
  regulation TEXT,                          -- レギュレーション（XY/SM/S/SV）
  card_number TEXT,                         -- カード番号（例: "102/193"）
  
  -- メタデータ
  rarity TEXT,                              -- レアリティ
  illustrator TEXT,                         -- イラストレーター
  effect_text TEXT,                         -- トレーナーズ/エネルギーの効果本文
  
  -- タイムスタンプ
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  last_verified_at TIMESTAMP                -- 最終確認日時
);

-- インデックス（PostgreSQL）
CREATE INDEX idx_cards_name ON cards(name);
CREATE INDEX idx_cards_category ON cards(category);
CREATE INDEX idx_cards_set_code ON cards(set_code);
CREATE INDEX idx_cards_regulation ON cards(regulation);
CREATE INDEX idx_cards_card_type ON cards(card_type);
CREATE INDEX idx_cards_evolution_stage ON cards(evolution_stage);
-- 全文検索用（GIN + to_tsvector。日本語は 'simple' が無難）
CREATE INDEX idx_cards_fulltext ON cards USING GIN(to_tsvector('simple', COALESCE(name,'') || ' ' || COALESCE(full_name,'')));
```

#### ワザ（技）情報テーブル（waza）

```sql
CREATE TABLE waza (
  id SERIAL PRIMARY KEY,
  card_id VARCHAR(5) NOT NULL REFERENCES cards(card_id) ON DELETE CASCADE,
  name TEXT NOT NULL,                       -- 技名
  name_clean TEXT,                          -- 技名（クリーン版）
  damage INTEGER,                           -- ダメージ
  damage_modifier TEXT,                    -- ダメージ付加記号: 'plus'（＋）, 'times'（×）, NULL
  effect TEXT,                              -- 技の効果説明
  order_index INTEGER DEFAULT 0,            -- 表示順序（1つ目、2つ目など）
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
CREATE INDEX idx_waza_card_id ON waza(card_id);
```

#### ワザのエネルギーコストテーブル（waza_energy_cost）

```sql
CREATE TABLE waza_energy_cost (
  id SERIAL PRIMARY KEY,
  waza_id INTEGER NOT NULL REFERENCES waza(id) ON DELETE CASCADE,
  energy_type TEXT NOT NULL,                -- エネルギータイプ（grass/fire/water/lightning/psychic/fighting/dark/metal/colorless）
  order_index INTEGER NOT NULL,             -- エネルギーコストの順序
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
CREATE INDEX idx_waza_energy_cost_waza_id ON waza_energy_cost(waza_id);
```

#### 特性（特性）情報テーブル（abilities）

```sql
CREATE TABLE abilities (
  id SERIAL PRIMARY KEY,
  card_id VARCHAR(5) NOT NULL REFERENCES cards(card_id) ON DELETE CASCADE,
  name TEXT NOT NULL,                       -- 特性名
  effect TEXT,                              -- 特性の効果説明
  order_index INTEGER DEFAULT 0,            -- 表示順序
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
CREATE INDEX idx_abilities_card_id ON abilities(card_id);
```

#### カードIDマッピングテーブル（card_id_mapping）

複数のレギュレーションで同じカードが存在する場合のマッピング用

```sql
CREATE TABLE card_id_mapping (
  id SERIAL PRIMARY KEY,
  base_card_id VARCHAR(5) NOT NULL,
  variant_card_id VARCHAR(5) NOT NULL,
  regulation TEXT,
  relationship TEXT,                        -- 関係性（same_card/reprint/alternate_art）
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
CREATE INDEX idx_card_id_mapping_base ON card_id_mapping(base_card_id);
CREATE INDEX idx_card_id_mapping_variant ON card_id_mapping(variant_card_id);
```

#### データ収集ログテーブル（collection_logs）

データ収集の進捗とエラーを記録

```sql
CREATE TABLE collection_logs (
  id SERIAL PRIMARY KEY,
  card_id VARCHAR(5),
  status TEXT NOT NULL,                     -- ステータス（success/error/skipped）
  source TEXT,                              -- データソース（deck_page/card_detail_page/api）
  error_message TEXT,
  processing_time_ms INTEGER,               -- 処理時間（ミリ秒）
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
CREATE INDEX idx_collection_logs_status ON collection_logs(status);
CREATE INDEX idx_collection_logs_created_at ON collection_logs(created_at);
```

---

## 2. データ収集戦略

### 2.1 採用方式：ハイブリッド（検索ページ ＋ 詳細ページ）

**フェーズ1: 基本情報の一括収集（検索ページ）**
- 公式カード検索ページの**初期表示（現行レギュレーション）**からカードID・名前・画像URL・詳細URL などを取得
- デフォルトは現行レギュレーションのみ。全レギュレーション（XY/SM/S/SV）が必要な場合は `--all` オプションで巡回
- PCGDECK または一覧HTMLから抽出し、`cards` に UPSERT

**フェーズ2: 詳細情報の段階的収集（詳細ページ）**
- `cards` のうち詳細未取得（例: `hp` が NULL）のカードについて、1枚ずつ詳細ページにアクセス
- ポケモン: HP・タイプ・進化段階・ワザ・特性・弱点・抵抗力・にげるコスト など
- トレーナーズ（グッズ/ポケモンのどうぐ/サポート/スタジアム）: カテゴリ・効果本文（`effect_text`）
- エネルギー: 種別（基本/特殊）・タイプ（複合は「草/炎」形式）・効果本文
- 結果は `cards` 更新および `waza` / `waza_energy_cost` / `abilities` に保存

### 2.2 詳細ページからの抽出方針

- **見出し（h2）起点**でセクションを特定（ワザ／特性／グッズ／サポート／スタジアム／基本・特殊エネルギー）
- **弱点・抵抗力・にげる**は、表のヘッダ文字列で該当テーブルを特定してから取得
- **エネルギータイプ**はカード名および効果本文から判定し、複合の場合は「草/炎」のようにスラッシュ区切りで保存
- **レアリティ・セットコード**は画像URLやリンクから推定

---

## 3. カードIDリストの取得方法

### 3.1 検索ページから抽出（推奨・現行実装）

1. **現行レギュレーション（デフォルト）**
   - 公式カード検索ページは初期表示で**現行レギュレーション**のカードが表示される
   - 検索ボタン実行後の一覧＋ページ送りで全件を取得
   - カードID・名前・画像URL・詳細URL などを `cards` に挿入

2. **全レギュレーションを取得する場合**
   - `--all` オプションで XY → SM → S → SV の順に巡回
   - 各レギュレーションでページ送りしながら取得

3. **既存データとの整合**
   - 既に存在する `card_id` は UPSERT（更新）で上書き

### 3.2 その他の取得方法（参考）

- **デッキページ**: デッキコードからカードIDを抽出する方法もあるが、検索ページの一括取得を優先
- **カードID範囲の総当たり**: 404が多く非効率なため非推奨

---

## 4. データ収集スクリプトの設計

### 4.1 現行のスクリプト構成（server/scripts 等）

```
server/
├── scripts/
│   ├── init-db.js              # スキーマ初期化（schema.sql 実行）
│   ├── verify-db.js            # DB接続確認
│   ├── collect-card-ids.js      # 検索ページからカードID・基本情報を収集（現行レギュレーション or --all）
│   └── collect-details.js      # 詳細ページから HP・ワザ・特性・effect_text 等を収集
├── database/
│   └── schema.sql              # テーブル定義
└── src/
    ├── db.js                    # DB接続
    ├── services/
    │   ├── scraper.js           # 検索ページの取得・一覧抽出
    │   └── cardDetail.js        # 詳細ページの取得・パース（ポケモン/トレーナーズ/エネルギー対応）
    └── utils/
        └── browser.js           # Puppeteer ページ生成
```

### 4.2 収集フロー

**基本情報（collect-card-ids）**
1. 検索ページを開く（現行レギュレーション or 指定レギュレーション）
2. 検索実行後、一覧からカード情報を抽出（PCGDECK または HTML）
3. ページ送りで全件取得し、`cards` に UPSERT

**詳細情報（collect-details）**
1. `cards` から詳細未取得（例: `hp IS NULL`）を LIMIT 件取得
2. 各 card_id で詳細ページにアクセス
3. 見出し起点でセクションをパースし、`cards` / `waza` / `waza_energy_cost` / `abilities` を更新
4. 1カードあたり約 1.2 秒待機（レート制限）
5. 結果を `collection_logs` に記録。複数回実行で未取得分を継続取得

### 4.3 エラーハンドリング

- **ネットワークエラー**: リトライ（最大3回、指数バックオフ）
- **404エラー**: カードが存在しないためスキップ
- **パースエラー**: ログに記録してスキップ
- **データベースエラー**: ログに記録してリトライ

---

## 5. 段階的な構築計画

### フェーズ1: 準備フェーズ

**目標**: データベースとスキーマの準備

1. **PostgreSQL のセットアップ**
   - データベース `pokeca` を作成
   - 環境変数（`.env`）で接続情報を設定

2. **スキーマの作成**
   - `npm run db:init` で `server/database/schema.sql` を実行
   - `cards` / `waza` / `waza_energy_cost` / `abilities` / `collection_logs` 等を作成

3. **接続確認**
   - `npm run db:verify` で接続を確認

### フェーズ2: 現行レギュレーションの基本情報収集

**目標**: 現行レギュレーションのカードID・基本情報を一括取得

1. **検索ページからの収集**
   - `npm run db:collect-ids` を実行（デフォルトで検索ページの初期表示＝現行レギュレーション）
   - カードID・名前・画像URL・詳細URL などを `cards` に挿入

2. **全レギュレーションが必要な場合**
   - `node scripts/collect-card-ids.js --all` で XY/SM/S/SV を巡回

### フェーズ3: 詳細情報の収集

**目標**: 各カードの詳細（HP・ワザ・特性・トレーナーズ/エネルギーの効果本文など）を取得

1. **詳細ページからの収集**
   - `npm run db:collect-details`（デフォルト 50 件）または `--limit=N` で実行
   - 詳細未取得（`hp IS NULL` 等）のカードを順次処理
   - 複数回実行で未取得分を継続取得可能

2. **運用**
   - 1リクエストあたり約 1.2 秒待機。大量収集時は `--limit` で区切って実行推奨

### フェーズ4: 最適化と運用（継続的）

**目標**: 検索APIのDB利用・データ品質・更新体制の確立

1. **検索のDB化**
   - API をスクレイピングから DB 検索に切り替え

2. **データ品質**
   - 欠損データの補完、`collection_logs` の確認

3. **更新**
   - 新カード追加時に `db:collect-ids` 再実行、続けて `db:collect-details` で詳細を補完

---

## 6. 技術スタックの選択

### 6.1 データベース

#### オプション1: SQLite（開発・小規模運用）

**メリット:**
- セットアップが簡単
- ファイルベースで管理が容易
- 開発環境に最適

**デメリット:**
- 同時書き込みに弱い
- 大規模データには不向き

**推奨用途**: 開発環境、小規模な運用

#### オプション2: PostgreSQL（本番環境推奨）

**メリット:**
- 高パフォーマンス
- 全文検索機能（FULLTEXT）が強力
- スケーラブル
- JSON型サポート

**デメリット:**
- セットアップがやや複雑
- サーバーが必要

**推奨用途**: 本番環境、中規模以上の運用

#### オプション3: MySQL

**メリット:**
- 広く使われている
- ドキュメントが豊富
- 多くのホスティングサービスで利用可能

**デメリット:**
- 全文検索がPostgreSQLほど強力ではない

**推奨用途**: 既存のMySQL環境がある場合

### 6.2 ORM / データベースライブラリ

- **Sequelize**: Node.js用のORM（PostgreSQL/MySQL/SQLite対応）
- **Prisma**: モダンなORM（型安全）
- **Knex.js**: クエリビルダー（柔軟性が高い）

### 6.3 データ収集ライブラリ

- **Puppeteer**: 検索ページ・詳細ページの表示と JavaScript 実行後の DOM 取得（現行実装で使用）
- **axios**: HTTPリクエスト（静的HTML取得に利用する場合）
- **cheerio**: サーバーサイドjQueryライクなHTMLパース

---

## 7. データ更新戦略

### 7.1 更新頻度

- **新カードの検出**: 週1回
- **既存カードの検証**: 月1回
- **詳細情報の更新**: 必要に応じて（公式サイトの変更時）

### 7.2 更新方法

1. **差分更新**
   - 新規カードのみを収集
   - 変更されたカードのみを更新

2. **フルスキャン**
   - 定期的に全カードを再確認
   - データの整合性を保証

3. **オンデマンド更新**
   - ユーザーが検索したカードが存在しない場合
   - その場で公式サイトから取得して保存

---

## 8. データ品質管理

### 8.1 データ検証

- **必須フィールドの確認**: カードID、名前は必須
- **データ形式の検証**: カードIDは5桁の数字
- **URLの有効性確認**: 画像URLと詳細URLが有効か

### 8.2 エラーハンドリング

- **収集失敗の記録**: collection_logsテーブルに記録
- **リトライ機能**: 一時的なエラーは自動リトライ
- **手動修正**: エラーログから手動で修正が必要なデータを特定

### 8.3 データ補完

- **欠損データの特定**: データベースに存在するが情報が不完全なカード
- **段階的な補完**: 優先度をつけて欠損データを補完

---

## 9. パフォーマンス最適化

### 9.1 インデックス戦略

- **検索用インデックス**: name, category, set_code
- **結合用インデックス**: card_id（外部キー）
- **全文検索インデックス**: name, full_name

### 9.2 キャッシュ戦略

- **アプリケーションレベル**: よく検索されるカードをメモリにキャッシュ
- **データベースレベル**: クエリ結果のキャッシュ
- **CDN**: 画像URLのキャッシュ（公式サイト側）

### 9.3 クエリ最適化

- **LIMIT句の使用**: 検索結果は適切な件数に制限
- **必要なカラムのみ取得**: SELECT * を避ける
- **JOINの最適化**: 必要なテーブルのみ結合

---

## 10. 運用上の考慮事項

### 10.1 レート制限

- **公式サイトへの負荷軽減**: リクエスト間隔を1秒以上
- **同時リクエスト数の制限**: 最大3-5リクエストまで
- **User-Agentの設定**: 適切なUser-Agentを設定

### 10.2 監視とアラート

- **収集進捗の監視**: 1日の収集件数を記録
- **エラー率の監視**: エラー率が一定以上になったらアラート
- **データベースサイズの監視**: ディスク容量の確認

### 10.3 バックアップ

- **定期的なバックアップ**: 日次または週次
- **バックアップの検証**: バックアップが正常に動作するか確認
- **災害復旧計画**: データ損失時の復旧手順

---

## 11. コスト見積もり

### 11.1 開発コスト

- **データベース設計**: 1-2週間
- **収集スクリプトの開発**: 2-4週間
- **テストとデバッグ**: 1-2週間
- **合計**: 4-8週間

### 11.2 運用コスト

- **データベースサーバー**: 月額1,000-5,000円（小規模）
- **ストレージ**: 初期10-50GB、月額数百円
- **ネットワーク**: データ収集時の通信量

### 11.3 時間コスト

- **初期データ収集**: 2-4週間（バックグラウンド実行）
- **継続的な更新**: 週1-2時間のメンテナンス

---

## 12. リスクと対策

### 12.1 技術的リスク

**リスク**: 公式サイトの構造変更によりスクレイピングが失敗
**対策**: 
- エラーハンドリングの強化
- 定期的な動作確認
- フォールバック機能の実装

**リスク**: データベースの破損
**対策**:
- 定期的なバックアップ
- トランザクションの適切な使用
- データ整合性チェック

### 12.2 法的リスク

**リスク**: スクレイピングの利用規約違反
**対策**:
- 公式サイトの利用規約を確認
- レート制限を遵守
- 適切なUser-Agentを設定
- 必要に応じて公式に問い合わせ

### 12.3 運用リスク

**リスク**: データ収集の停止
**対策**:
- 自動リトライ機能
- 監視とアラートの設定
- 手動実行の手順書作成

---

## 13. 成功指標（KPI）

### 13.1 データ収集の指標

- **カード収集率**: 目標95%以上
- **データ完全性**: 必須フィールドの欠損率5%以下
- **収集速度**: 1時間あたり500-1000カード

### 13.2 パフォーマンス指標

- **検索応答時間**: 平均100ms以下
- **データベースサイズ**: 初期10-50GB
- **クエリ成功率**: 99%以上

### 13.3 運用指標

- **エラー率**: 1%以下
- **データ更新頻度**: 週1回以上
- **システム稼働率**: 99%以上

---

## 14. 次のステップ

### 即座に開始できること

1. **データベースのセットアップ**
   - PostgreSQL で DB `pokeca` を作成
   - `server/.env` を設定し、`npm run db:init` でスキーマ作成
   - `npm run db:verify` で接続確認

2. **現行レギュレーションの基本情報収集**
   - `npm run db:collect-ids` で検索ページからカードID・基本情報を取得（現行レギュレーション）

3. **詳細情報の収集開始**
   - `npm run db:collect-details` または `node scripts/collect-details.js --limit=100` で未取得カードの詳細を取得

### 短期（1-2ヶ月）

1. **詳細情報の網羅**
   - `db:collect-details` を繰り返し実行（または `--limit` を大きくして）未取得分を解消

2. **検索APIのDB利用**
   - 検索・詳細取得をスクレイピングから DB 参照に切り替え

### 中期（3-6ヶ月）

1. **全レギュレーション対応（必要な場合）**
   - `node scripts/collect-card-ids.js --all` で XY/SM/S/SV を収集し、続けて詳細収集

2. **データ品質・最適化**
   - 欠損データの補完、`collection_logs` の確認、検索パフォーマンスの見直し

---

## まとめ

データベース構築は段階的に進めることで、リスクを最小化しながら確実にデータを蓄積できます。

**推奨アプローチ（現行実装に沿った流れ）:**
1. **フェーズ1**: PostgreSQL をセットアップし、`npm run db:init` でスキーマを作成
2. **フェーズ2**: `npm run db:collect-ids` で**現行レギュレーション**のカードID・基本情報を検索ページから一括収集
3. **フェーズ3**: `npm run db:collect-details` で詳細ページから HP・ワザ・特性・効果本文などを段階的に収集
4. **フェーズ4**: 検索APIをDB利用に切り替え、データ更新・品質管理を継続

**ポイント:**
- 検索ページはデフォルトで現行レギュレーションが抽出されるため、ひとまず現行分のみ収集する運用が可能
- 全レギュレーション（XY/SM/S/SV）が必要な場合は `collect-card-ids.js --all` で対応
- 詳細ページの抽出は見出し（h2）起点でポケモン／トレーナーズ／エネルギーを統一して扱い、`card_type` の複合表現は「草/炎」形式で保存

この計画に従って進めることで、高速で信頼性の高いポケモンカード検索システムを構築できます。
